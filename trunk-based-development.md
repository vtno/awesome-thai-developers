# Trunk-Based Development
by [@vtno](https://github.com/vtno)

จะพูดถึง trunk-based development ก่อนอื่นต้องพูดถึง version control ก่อนครับ

version control เป็นสิ่งที่ทีม software สมัยนี้ต้องมีเป็น standard ครับ จะใช้ยี่ห้อไหนก็ได้ แต่ที่ใช้กันส่วนมากและหลาย ๆ คนคงใช้กันอยู่แล้วคือ git (ไม่ใช่ github นะครับ)
ผมขอ skip การอธิบายว่ามันคืออะไรแล้วกันครับ ถ้ารวมไว้น่าจะยาวเกิน โดยสามารถหาอ่านได้ทั่วไปเลยครับสำหรับคนที่ไม่รู้ว่า version control คืออะไร

โดยทีมผมใช้ version control ในการทำงานแบบที่เรียกว่า trunk-based development ครับ

การทำงานคร่าว ๆ จะเป็นไปตามนี้ครับ (ทีมผมใช้ git กับ github ครับ)

1. มี main branch อันเดียวจะตั้งชื่อว่าอะไรก็ได้ แต่ส่วนใหญ่จะตั้งชื่อว่า main หรือ master
2. การทำงานแต่ละชิ้นจะต้องแยกอยู่ใน branch ตัวเองและเปิด pull request ใส่ main เท่านั้น และตอนกด merge เราใช้การ squash merge ครับ (คือการยุบ commit จาก branch เหลือ commit เดียวเป็นชื่อ pull request ก่อน merge)
3. ใน main และทุก ๆ pr build จะต้องเขียว (linter ผ่าน, test ผ่าน, format ผ่าน) และของที่เข้าไปใน main จะถูก deploy ขึ้น staging (qa environment) อัตโนมัติ
4. หลังจากที่ deploy ไปแล้วโปรแกรมเมอร์เจ้าของงานจะ pair กับ qa หรือ stakeholder (หลาย ๆ ครั้งคือตัวลูกค้าที่จ้างทำเองเลย) เพื่อ verify ตัว feature ครับ
5. ส่วนมากถึงจุดนี้ถ้ามีแก้ก็จะกลับไปแก้นิด ๆ หน่อย ๆ วนไปข้อ 2 ใหม่ แต่ถ้าไม่มีก็จะเอาขึ้น production เลย เผื่อให้ production อัพเดตอยู่เสมอครับ
6. กรณีมีปัญหาหรือขึ้นไปแล้วแตก (น้อยมาก ๆ) เราใช้การ revert commit ที่ squash มาทิ้งแล้ว deploy ใหม่ ทำให้การแก้ไขปัญหาเกิดขึ้นทันทีที่ตรวจเจอครับ (ไอการ detect ว่าแตกไม่แตกเดี๋ยวว่ากันตอนผมพูดเรื่อง monitoring กับ alerting)

ทีมผมทำงานตามนิยามนี้ครับ integrate early, integrate often

มันแปลว่่าเวลาเขียนโปรแกรมกันหลาย ๆ คนเนี่ยควรจะเอาโค้ดมารวมกันให้ไวที่สุดและบ่อยที่สุดเท่าที่จะทำได้ ซึ่งโปรแกมเมอร์ในทีมผมจะแพลนตัวเองตามงานที่ได้รับ assign ครับ ตัวอย่าง เช่น

week นี้ทีมต้องการทำระบบแจกคะแนนให้ลูกค้าหลังซื้อของครบยอด โปรแกรมเมอร์ในทีมก็จะเอา feature ใหญ่นี้ไปหั่นให้เล็กลงแล้วแบ่งกันทำออกมาครับ ตัวอย่างของการแบ่งงานอาจจะเป็น

นาย ก ทำ flow การสร้าง order โดยแบ่งเป็น

- design data model แล้วเขียนโค้ดออกมา
- implement controller action สำหรับการสร้าง order แล้วเขียน request test ครอบตรวจสอบว่าทำงานได้จริง

นางสาว ข แบ่่งทำ cron job เช็คยอดซื้อของลูกค้าที่รันเป็นรายชั่วโมง

- ใช้ data model จากนาย ก มาทำ query เพื่อหายอดซื้อของลูกค้า + เขียน test สำหรับ query นั้น
- implement job เพื่อรันลอจิคการรวมยอดซื้อและคำนวณคะแนนและ update point transaction ให้ลูกค้าแต่ละคน

จะเห็นได้ว่างานของนางสาว ข ต้องรอนาย ก design data model ออกมาก่อน ซึ่งถ้าเราไม่แบ่งงานให้ดี แทนที่นางสาว ข จะเริ่มงานของตัวเองได้เลยก็ต้องมานั่งรอนาย ก ทำ flow สร้าง order เสร็จทั้่งหมด

flow การทางานของในทีมผมจะเป็นแบบนี้ครับ

1. นาย ก และนางสาว ข pair กัน design data model และเปิด pull request ให้คนในทีมรีวิว เพื่อ unblock ทั้งคู่
2. หลัง approve ทั้งคู่ merge PR เข้า main branch โดยตรงเลย แล้ว checkout ไปทำงานส่วนของตัวเองต่อใน branch ใหม่
3. นางสาว ข ทำงานส่วนของตัวเองเสร็จก่อนเปิด pull request ให้คนในทีมรีวิว แก้ตาม comment
4. นาย ก ทำงานส่วนของตัวเองเสร็จเปิด pull request ให้คนในทีมรีวิว ระหว่างนี้นางสาว ข ก็เทสกับลูกค้าบน staging เรียบร้อยแล้วเอาขึ้น production ปิดงาน ไปทำงานถัดไปต่อ
5. นาย ก ทำส่วนการสร้าง order เสร็จไปเทสกับลูกค้าแล้ว deploy ขึ้น production กลับมา เริ่ม PR ใหม่เพื่อ integrate ตัว job ที่นางสาว ข ทำไว้แล้วเข้าลูปเดิม

จะสังเกตุได้ว่าการทำงานแบบนี้มีข้อดีหลายอย่างเลยครับ

- แต่ละคนแบ่งงานทำคนละส่วนได้โดยไม่ขัดกัน เพราะ แบ่งงานไว้ดี
- ลูกค้าเข้ามามีส่วนตั้งแต่เนิ่น ๆ โอกาสทำงานผิดจากที่ลูกค้าอยากได้น้อย ลูกค้าได้ sign off แต่ละ feature แยกกันเลย และ feature นั้่น ๆ ไป production ทันที
- เวลามีบัคสามารถ patch เข้า main หรือ revert ทิ้งได้ทันที ทำให้ผลกระทบที่ลูกค้าเจอน้อยมาก (ต่างกับ git-flow ที่ยังต้อง merge hotfix กลับไป staging หรือ development branch อีก ซึ่งมีโอกาส conflict สูงต้องมาแก้กันปวดหัว)
- project manager เห็น progress ตลอด เพราะ โปรแกรมเมอร์แบ่งงานเป็นส่วนเล็ก ๆ ไม่จำเป็นต้องรอหลายวันกว่าจะเห็นงาน ลูกค้าอยู่ใน loop เวลามีการเปลี่ยนแปลงทุกคนรับรู้ โดยไม่ต้องมี meeting แยก

สิ่งที่จำเป็นต้องมีที่จะทำให้การทำงานแบบนี้เวิร์คได้คือ

- โปรแกรมเมอร์ต้อง manage ตัวเองได้ ไว้ใจได้ ซึ่งพูดเหมือนง่ายแต่โปรแกรมเมอร์ที่ทำตามคำสั่งอย่างเดียวมีอยู่เยอะมากครับ ซึ่งตรงนี้ต้องคัดตั้งแต่ตอนสัมภาษณ์
- CI/CD pipeline ต้องมี ไม่งั้นใคร merge อะไรเข้ามาทีมไม่รู้เลยว่าทำอย่างอื่นพังหรือเปล่าและการ deploy มันไม่ควรต้องมา manual ไม่งั้นทุกคนในทีมก็ต้องมาหัด deploy กันทุกคนอีก เป็นการลดงานซ้ำซ้อนครับ
- ตัวแทนจากฝั่งลูกค้าต้องเป็น product owner จริง ๆ ต้องเป็นคนที่ฟันได้ว่าอันไหนโอเคไม่โอเค ไม่งั้นการดึง PO ที่ไม่มีอำนาจการตัดสินใจเข้ามาทำให้เสียเวลาฟรีครับ เพราะ มีอีกคนที่ตัดสินใจได้อยู่ข้างบนอีก อันนี้สำคัญมาก ๆ ทีมผม make sure ทุกครั้งว่าคนจากฝั่งลูกค้าคือคนที่จบที่เขาได้เลย
- Monitoring กับ alerting ที่ดี สามารถ detect ปัญหาในระบบได้แบบ automate และสามารถแจ้่งเตือนมาที่ทีมได้ครับ เช่น Prometheus, Grafana, Alertmanager, DataDog, NewRelic และอื่น ๆ
ตรงนี้ทำให้สเตปสุดท้ายหลัง deploy เราไม่ต้องให้คนมานั่งเฝ้านั่ง UAT ในสิ่งที่ทำกันไปบน staging แล้วอีกรอบครับ

ท่านี้เป็นผลพวงจากการปรับไปปรับมาอยู่หลายปีของทีมผมครับ ใครมีกระบวนการทำงานแบบอื่น ๆ มาแชร์กันได้ครับ
